## Introduction to Haskell

*Haskell* --> a lazy functional programming language with a powerful type system 

**Features** 

Concise Programs<br>
Powerful Type System<br>
List Comprehension<br>
Recursive Function<br>
Higher Order Functions<br>
Effectful Functions<br>
Generic Functions<br>
Lazy Evaluation<br>
Equational Reasoning<br>

**Summing Numbers**<br>
mysum :: Num a => [a] -> a  <br>
    "a" is the type variable <br>
    "Num" is the constraint of the type (has to be a number) <br>
    "[a]" is a list of elements of type "a" <br>
    "=>" type constraint<br>
    "->"<br>

    "Num a => [a] -> a" a list of numbers of type a and return an element of type a

mysum[] = 0 <br>
    mysum with empty list will return 0

mysum(n:ns) = n + mysum ns<br>
    "n" is matched to the head <br>
    ":" cons<br>
    "ns" is matched to the tail

mysum2 ns = foldr(+) 0 ns<br>
    (+) combiner function


**Sorting Values** <br>
qsort :: Ord a => [a] -> [a]

qsort[] = []

qsort(x:xs) = qsort smaller ++ [x] ++ qsort larger<br>
    where<br>
        smaller = [a | a <- xs, a <= x]<br>
        larger = [b | b <- xs, b > x]<br>

ghci>qsort[3, 5, 4, 1, 2]<br>
    = qsort[1, 2] ++ [3] ++ qsort[5, 4]<br>
    ...<br>
    = [1, 2] ++ [3] ++ [4, 5] = [1, 2, 3, 4, 5]

"++" is append

**Sequencing Actions**<br>
seqn :: [IO a] -> IO[a]<br>
-- seqn :: Monad m => [m a] -> m[a]<br>
seqn[] = return []<br>
seqn(act:acts) = do x <- act<br>
                xs <- seqn acts<br>
                return (x:xs)

ghci>seqn[getChar, getChar, getChar]

**Currying**<br>
add :: (Int, Int) -> Int<br>
add(x, y) = x + y

add2 :: Int -> Int -> Int<br>
add2 x y = x + y

add3 :: Int -> (Int, Int)<br>
add3 = \x -> (\y -> x + y)<br>
    "\" similar to lambda

add4 :: Int -> Int -> Int -> Int<br>
add4 x y z = x + y + z

**List Processing**<br>
[1,2,3] = 1 : 2 : 3 : [] -- cons

[1,2,3,4,5] !! 2<br>
    ~ 3

head [1,2,3,4,5]<br>
    ~ 1

tail [1,2,3,4,5]<br>
    ~ [2,3,4,5]

length [1,2,3,4,5]<br>
    ~ 5

take 3 [1,2,3,4,5]<br>
    ~ [1,2,3]

drop 3 [1,2,3,4,5]<br>
    ~ [4,5]

[1,2] ++ [3,4,5]<br>
    ~ [1,2,3,4,5]

### Types and Classes

**Declaring data types**<br>
    1. type declarations<br>
    2. data declarations<br>
    3. recursive types<br>
    4. newtype declarations

**Declaring classes**<br>
    1. class<br>
    2. instance

**Type Declarations**

type string = [Char]<br>
type Var = Char

type Assoc k v = [(k,v)]<br>
type Env = Assoc Var Int<br>
--> env :: Env<br>
--> env = [('x', 2), ('y', 3)]

find::Eq k => k -> Assoc k v -> v<br>
    k = the type of the key<br>
    v = the type of the value<br>
    Eq k = keys must be comparable for equality (==)<br>
    Input:<br>
        A key<br>
        An association list (Assoc k v = usually a list of (key, value) pairs)<br>
    Output:<br>
        A value v

find k t = head [v | (k', v) <- t, k == k']<br>
    1. Loop through the list t<br>
        Each element is assumed to look like (key, value)<br>
    2. Pattern match each pair<br>
        (k', v) <- t<br>
        Means:<br>
            Extract the key (called 'k')<br>
            Extract the value v<br>
    3. Filter only matching keys<br>
        k == k'<br>
    4. Collect the matching values<br>
        [v | ... ]<br>
    5. Take the first match<br>
        head [...]

*Note: 'k' means character k, k' is variable k*

**Data Declarations**

data Bool = False | True

not Bool -> Bool<br>
not False = True<br>
not True = False<br>

(&&) :: Bool -> Bool -> Bool<br>
True && True = True

**Arithmetic Expressions**

data ArithExpr = Const Int<br>
                | Var Char<br>
                | Add ArithExpr ArithExpr<br>
                | Mult ArithExpr ArithExpr<br>
                deriving Show

**Class and Instance Declarations**<br>
class Eq a where<br>
    (==), (/=) :: a -> a -> Bool<br>
x /= y = (not x == y)

instance Eq Bool where<br>
    False == False = True<br>
    True == True = False<br>
    _ == _ = False *any other combonation of Bool will result in false*
