## Introduction to Haskell

Haskell --> a lazy functional programming language with a powerful type system

**Features**
Concise Programs
Powerful Type System
List Comprehension
Recursive Function
Higher Order Functions
Effectful Functions
Generic Functions
Lazy Evaluation
Equational Reasoning

**Summing Numbers**
mysum :: Num a => [a] -> a  
    "a" is the type variable
    "Num" is the constraint of the type (has to be a number)
    "[a]" is a list of elements of type "a" 
    "=>" type constraint
    "->"

    "Num a => [a] -> a" a list of numbers of type a and return an element of type a

mysum[] = 0
    mysum with empty list will return 0

mysum(n:ns) = n + mysum ns
    "n" is matched to the head 
    ":" cons
    "ns" is matched to the tail

mysum2 ns = foldr(+) 0 ns
    (+) combiner function


**Sorting Values**
qsort :: Ord a => [a] -> [a]

qsort[] = []

qsort(x:xs) = qsort smaller ++ [x] ++ qsort larger
    where
        smaller = [a | a <- xs, a <= x]
        larger = [b | b <- xs, b > x]

ghci>qsort[3, 5, 4, 1, 2]
    = qsort[1, 2] ++ [3] ++ qsort[5, 4]
    ...
    = [1, 2] ++ [3] ++ [4, 5] = [1, 2, 3, 4, 5]

"++" is append

**Sequencing Actions**
seqn :: [IO a] -> IO[a]
-- seqn :: Monad m => [m a] -> m[a]
seqn[] = return []
seqn(act:acts) = do x <- act
                xs <- seqn acts
                return (x:xs)

ghci>seqn[getChar, getChar, getChar]
